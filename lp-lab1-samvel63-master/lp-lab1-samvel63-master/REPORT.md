# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Мхитарян С.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|   16.10.17   |       4       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*
Неправильное написание предиката del_1

## Введение

Список - это абстрактный тип данных используемый для хранения упорядоченного набора элементов. Списки языка Prolog являются односвязными, т.е. каждый узел содержит лишь одну ссылку.<br>

В языке Prolog программист не сталкивается с явной работой с указателями в узлах, однако ему нужно иметь общее представление о списках, т.к. являясь основной структурой данных в функциональных и логических языках, они обладают рядом существенных отличий от массивов, используемых в императивных языках (таких как С++, Java, Pascal). В частности, элемент данных может быть очень быстро добавлен или удален из начала односвязного списка. Однако операция произвольного доступа (обращения к n-ному элементу) в списках выполняется гораздо дольше чем в массивах, т.к. требует n операций перехода по ссылкам.<br>

При работе с односвязными списками необходимо выделять первый узел (называемый головой списка), остальные узлы (составляющие хвост списка) можно получить передвигаясь по указателям вплоть до последнего узла. Хвост списка является таким же списком, как и исходный, поэтому обрабатывается аналогичным образом (рекурсивно).<br>

![Image alt](https://pro-prof.com/wp-content/uploads/2013/03/prolog-lists.png) <br>

## Задание 1.1: Предикат обработки списка

`del_1(X, Y, W)` - удаляет элемент по индексу без использования стандартных предикатов. <br>
`del_n(List, 1, Index, [], Res)` -  удаляет элемент по индексу с использованием стандартных предикатов.<br>
Примеры использования:
```prolog
| ?- del_1(1, [1, 2, 3, 4, 5], X).
X = [2,3,4,5]
yes
| ?- del_1(5, [2, 4, 6, 1, 40, 90], X).
X = [2,4,6,1,90]
yes
| ?- del_1(2, [3, 4, 5], X).
X = [3,5]
yes

| ?- del_n([1,2,3,3,4,5], 1, 3, [], List).
List = [1,2,3,4,5] ? 
yes
| ?- del_n([3],1,1,[],List).
List = []
yes
| ?- del_n([1, 3],1,3,[],List).
List = [1,3] ? 
yes
```

Реализация:
```prolog
del_1(_,[],[]).
del_1(1,[_|Tail],Tail) :-!.
    I1 is I-1,
    del_1(I1,Tail,NewTail).
...
del_n([] ,_ ,_ ,M ,M):-!.
del_n([H|T], Index, N, L, List):-
    Index < N,
    Index1 = Index + 1,
    append(L, [H], L2),
    del_n(T, Index1, N, L2, List).
 del_n([H|T], Index, N, L, List):-
    Index > N,
    Index1 = Index + 1,
    append(L, [H], L2),
    del_n(T, Index1, N, L2, List).   
del_n([_|T], Index, N, L, List):-
    Index1 = Index + 1,
    del_n(T, Index1, N, L, List).
```
Реализация предиката del_1(X, Y, W):<br>
Используя возмножность Prolog разбивать список на 'голову' и 'хвост', мы раскладываем список так, чтобы выделить хвост списка после трех элементов. Этот хвост и является ответом.

Реализация предиката del_n(List, 1, Index, [], Res):<br>
Перебирается список с помощью разбиения на 'голову' и 'хвост' и каждый элемент добавляется в пустой список, кроме элемента, который стоит на н-ой позиции.

## Задание 1.2: Предикат обработки числового списка

`sumall(X, Y, N)` - сумма двух векторов-списков (Реализация без стандартных предикатов) <br>
`sumOfTwoLists(X, Y, N)`- сумма двух векторов-списков (Реализация с применением стандартных предикатов) <br>
Примеры использования:
```prolog
| ?- sumall([1, 3, 1], [2, 0], X).
X = 7
yes
| ?- sumall([1, 2], [1, 2], X).
X = 6
yes
| ?- sumall([1, 2, 3], [5, 20], X).
X = 31
yes
| ?- 
| ?- sumOfTwoLists([1, 3, 1], [2, 0], X).
X = 7
yes
| ?- sumOfTwoLists([1, 2], [1, 2], X).
X = 6
yes
| ?- sumOfTwoLists([1, 2, 3], [5, 20], X).
X = 31
yes
| ?- 
```

Реализация:
```prolog
% Без использования стандартных предикатов
sum([],0).
sum([H|T],Sum):-  
    sum(T,Sum1),  
    Sum=H+Sum1.

sumall([], [], 0).
sumall(X, Y, N) :-
    sum(X, A),
    sum(Y, B),
    N is A + B.
...
% С использованием стандартных предикатов
sumOfTwoLists([], [], 0).
sumOfTwoLists(X, Y, N) :-
    sum_list(X, A),
    sum_list(Y, B),
    N is A + B.
```
Реализация предикатов  sumall(X, Y, N) и sumOfTwoLists(X, Y, N) ничем не отличается кроме как собственной реализацией стандартного предиката sum_list:
Считаем сумму элементов первого и второго вектора, затем просто складываем эти два числа.

## Задание 2: Реляционное представление данных

Типы моделей данных:
* Иерархическая модель 
* Сетевая модель 
* Реляционная модель 

В реляционной модели данных объекты и взаимосвязи между ними представляются с помощью таблиц. 
Взаимосвязи рассматриваются в качестве объектов.

Преимущества реляционного представления:

* удобное для пользователя представление объектов в виде таблиц
* возможность использования непроцедурных языков для работы 
* основа модели - математический аппарат, который позволяется строго описывать операции над данными
* независимость данных

Недостатки реляционного представления:

* не все необходимые для описания сферы можно представить в виде таблиц
* большой расход памяти для представления
* низкая скорость при выполнении операции соединения

Преимущества представления в one.pl:

* получение оценки студента за экзамен
* легко узнать номер группы студента

Недостатки представления в one.pl:

* по сравнению с four.pl, для пользователя неудобно то, что нельзя по номеру группы получить список группы, а для предмета - оценки.
* по сравнени. с three.pl неудобно то, что для студента нельзя получить список его оценок.

Предикаты реализованные для работы с one.pl:

* group(X,L) - выводит список группы
* average_mark(X, Y) - средняя оценка 
* marks(X, C) - список оценок студента за экзамены
* studentAverageMark(X, Res) - средняя оценка студента за экзамены
* studentCheckPassExam(X) - проверка, сдали ли студент экзамены
* studentNumberOfFailedExam(X, N) - кол-во студентов не сдавших предмет
* groupMaxAverageMark(X, Res) - максимальный средний балл в группе

## Выводы

В лабораторной работе прошло знакомство с языком Prolog и компилятором GNU Prolog. Были написаны предикаты обработки списков и числовых списков со стандартными и без стандартных предикатов. Так же были реализованы запросы к реляционному представлению данных.<br>

Prolog является декларативным языком программирования, это был первый подобный опыт, т.к. приходится работать только с императивными языками(С, С++, Python, JavaScript). Интересно то, что в Prolog нет циклов и всё реализуется через обычную рекурсию.<br>

При программировании на Prolog усилия программиста должны быть направлены на описание логической модели фрагмента предметной области решаемой задачи в терминах объектов предметной области, их свойств и отношений между собой, а не деталей программной реализации. Фактически Prolog представляет собой не столько язык для программирования, сколько язык для описания данных и логики их обработки.<br>

Основные области применения Prolog:

* быстрая разработка прототипов прикладных программ;
* автоматический перевод с одного языка на другой;
* создание естественно-языковых интерфейсов для существующих систем;
* символьные вычисления для решения уравнений, дифференцирования и интегрирования;
* проектирование динамических реляционных баз данных;
* экспертные системы и оболочки экспертных систем;
* автоматизированное управление производственными процессами;
* автоматическое доказательство теорем;
* полуавтоматическое составление расписаний;
* системы автоматизированного проектирования, базирующееся на знаниях программное обеспечение;
* организация сервера данных или, точнее, сервера знаний, к которому может обращаться клиентское приложение, написанное на каком-либо языке программирования.<br>

Недостатком языка является отсутствие его практической пользы. т.к. он не очень популярен. По индексу TIOBE, Prolog занимает  лишь 30 место.<br>

Мне кажется, что Prolog влияет положительно на развитие в программировании . Так что знакомство с языком было увлекательным. <br>
