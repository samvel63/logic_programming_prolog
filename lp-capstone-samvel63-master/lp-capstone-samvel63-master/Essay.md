# Реферат
## по курсу "Логическое программирование"

### студент: Мхитарян С.А.

## ТЕМА
Что было бы, если бы человечество придумало Prolog как первый язык программирования?(Вариант 11)

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

По моему мнению, если бы так было, то ЭВМ были бы абсолютно другими и порог вхождения в программирование был бы еще выше, чем в случае Ассемблера как первого языка. Так-как для понимания и работы с Prolog’ом нужно знание дискретной математики и математической логики на достаточно высоком уровне, также подразумевается, что процессоры ЭВМ поддерживают предикаты Пролога, что дает огромную эффективность программ, но поддержку предикатов совершается каким-то высокотехничным способом. Не совсем понятно, какова была аппаратная реализация Пролога и какие габариты имели бы такие устройства, а также их доступность рядовому пользователю или университету, особенно, если брать уровень развития, габариты и стоимость ЭВМ в годы появления Ассемблера. Возможно, Пролог-машины были бы чем-то вроде Лисп-машин, которые вместо списков принимали какие-то базовые предикаты, являющиеся операциями в определенной математической группе, которую нашли ученые и которая является подходящей для машинной реализации, либо Пролог базировался бы на позднее изобретённом ассемблере и заменил собой язык программирования Си, но тогда почему бы не появиться потом и Си, а затем и другим языкам. Таким образом мы придем в реальность, в которой Пролог занимает то же место, что и сейчас. Но рассматривать я буду случай, если бы существовали и использовались Пролог-машины.<br>

Допустим, архитектура операционных систем останется нынешней, но сами операционные системы будут более надежными в силу того, что Пролог, при аппаратной поддержке, эффективно находит ответы на запросы пользователя или подпрограмм, но интересна реализация системных прерываний, планировщика ядра, файловых систем и прочих важных частей системы, которые являются недетерменированными и сложными в реализации в императивных языках, не говоря уже про эффективную версию в декларативных(если такое возможно). <br>

Также была бы интересной реализация графики – параметризованные векторы как факты, а не как функции. Учитывая сложность параметризации реальной фигуры, можно представить себе, сколько времени уйдет на параметризацию в Прологе. Но как только люди научатся этому, можно будет описывать предметы как сочетания описаний базовых и сложных фигур, что звучит заманчиво и более художественно, чем нынешние эффективные способы работы с графикой, которые просто осуществляют множество рассчетов и работ с матрицами. Или можно пойти проторенной дорогой и продолжить работать с матрицами, в этом случае все было бы примерно так же, как и сейчас, только с более дружественным интерфейсом, а если будут графические Пролог-процессоры, то работа с матрицами будет такой же эффективной, как и в случае ассемблерных процессоров, но, как было упомянуто выше, с дружественным интерфейсом, на основе которого можно было создать еще более дружественный интерфейс для дизайнеров, что лишило бы часть программистов работы.<br>

Возможно, многопроцессорность еще дольше входила бы в оборот, так-как на Прологе проще работа с деревьями, а на их основе можно сделать конечный автомат, который при правильной архитектуре может быть эффективней параллельных вычислений. А когда возможности конечного автомата перестанут удовлетворять промышленным требованиям и параллельные вычисления войдут в обиход, то тут у Пролога могут возникнуть конкуренты в лице функциональных языков, так-как чистые функции в силу своей прозрачности и иммутабельности данных (для изменения части объекта возвращается новый объект с измененной частью, а не изменяется исходный).<br>

Реализация интернет-технологий была бы проще по причине легкости переноса теорий кодирования на аппараты, ведь они принимают инструкции на Прологе, который идеально подходит для решения теорем. Но интернет – достаточно нестабильная вещь, так что он привносит недетерминированность, что является плохим признаком для программы на Прологе и должны быть какие-то аппаратные или программные ограничения на случай недетерменированной проблемы, как, например, ожидание ответа от сервера или асинхронная работа между сервером или клиентом. Но даже в нашей вселенной императивного программирования некоторые версии Пролога имеют фреймворки для работы с интернетом, например SWI-Prolog, так что не стоит беспокоится о возможном пребывании в вечном интернете начала нулевых в нашем случае.<br>

Также возможно, что была бы создана база фактов на естественном языке, которая была бы подобием искусственного интеллекта, ведь для этого и создавался Пролог. Тогда мир был бы совсем другим и машины применялись в еще большем количестве сфер, чем сейчас. Нас бы обслуживали роботы-официанты, роботы-кассиры, возможно, человек смог бы создать и более сложные аппараты или роботов-помощников, которые помогали бы ему в придумывании вещей и их реализации. Однако, и здесь встает проблема детерминированности, выражающаяся в действиях и реакциях роботов на нестандартные или несколько отличающиеся от имеющихся в базе данных события. На эту тему можно написать еще один реферат, но нам важней вселенная Пролога, так что оставим исследование поведения роботов учёным из “логической вселенной”.<br>

Еще было бы проще создавать модели событий, ведь для этого достаточно описать факты события и влияющих на него факторов. Люди смогли бы иметь достаточно точные сейсмологические, погодные и, возможно, экономические (что больше подходит для искусственного интеллекта) прогнозы на основе собранных с датчиков данных. Но точность прогноза зависит от точности математической модели, создание которой порой весьма нетривиальная задача даже в случае её детерминированности, не говоря уже про модели с возможностью возникновения недетерминированных событий (многие ситуации в жизни) и точности датчика, который является либо механическим, либо запрограммированным, и тут встает вопрос, на каком языке будет написана его начинка? Если на Прологе, то при корректном и детерминированном алгоритме замера, аппаратной поддержке данного языка реализация и использование будут проще аналогичных действий при использовании в разработке императивных языков, в случае использования императивного языка для работы с аппартной частью, я бы отдал предпочтение другому языку(императивному или функциональному) для более высокоуровневой работы в датчике, так-как  недетерминированные ситуации рано или поздно произойдут, а с их решением у Пролога, как было упомянуто многократно ранее, проблемы.<br>

Но в научной среде для доказания или показания хода решения теорем Пролог определенно бы занял уверенное место заменив собой библиотеку на языке программирования Python NumPy, которая обладает мощным функционалом для работы с математическими задачами. Также, если у ученых получится создать базу базовых терминов, аксиом и интерфейс к ней, который позволял бы находить недостающие шаги в заданных теоремах, то это позволит сделать науке огромный шаг вперед.<br>

Для сложных математических вычислений, пришлось бы создать “числодробильные” процессоры, которые бы строили деревья выражений в Прологе и с помощью ленивых вычислений выдавали результат. Наверняка инженеры всего мира возблагодарят создателей Пролога и процессоров за такое облегчение работы. Также стало бы легче и проектирование задач связанных с вычислением(при условии обладания уверенным знанием Пролога), так-как не нужно прибегать к императивному Фортрану и думать об изменениях состояния или утечках памяти.<br>

Стоит упоминания габариты Пролог-машин, если в 60-ые ЭВМ занимали целые комнаты и использовали простые команды, то место под Пролог-машины потребовалось бы раза в 3 больше, либо ученые нашли более эффективные методы для хранения компьютерных сигналов, что уменьшило бы размер ЭВМ. Также была бы интересной история повяления сортировок, как они бы появлялись в головах своих изобретателей, которые бы рассматривали магнитные ленты как списки или нечто подобное и реализация алгоритмов занимала еще меньше места, чем формальное описание, не говоря про его сумму с доказательством корректности. Наверняка в этом им бы помогали упомянутые ранее машины для доказательства, а для вычисления сложности – математические процессоры.<br>

Также при должном уровне развития технологий, компании получили бы еще более удобный и естественный способ сбора информации, например, для маркетинга, разведки целевой аудитории, контекстной рекламы, поиска в интернете, потому что Пролог применяется для подобных целей и сейчас, а если на него будет потрачено столько же времени, сколько на работу с текстом с использованием императивных языков, то можно было бы еще быстрей приблизить тёмное будущее сверх-корпораций, которые контроллируют жизнь обывателей и за доли секунд узнают информацию о нужной им информации.<br>

Но какие бы проблемы имел мир Пролога? Самая главная – решение недетерминированности, её я упоминал практически в каждом абзаце, затем, написание эффективной программы(решение дерева состояний обходом в ширину весьма прожорливо по отношению к памяти), которая не относится к обработке текстовой информации, деревьев состояний и интерпритации данных, реализация чисел с плавающей точкой в случае Пролог-машин. Также в силу определенной сложности понимания языка, распространение ЭВМ и IT-технологий будет медленней нашей реальности, так-как многих наверняка будет пугать работа с большим количество математики(которая в наше время, например, в большинстве случаев в программировании используется по минимуму) и поэтому будет меньше желающих создать продукт, либо это кому-то надоест и он изобретет  Ассемблер, потом Фортран, и всё вернется на круги своя - к работе с фреймворками, формами и повсеместному использованию ЭВМ и компьютерных технологий.<br>

В заключение хотелось бы сказать, что мир с Прологом выглядит радужней нынешнего, но, возможно, даже скорее всего, если Пролог был бы первым языком программирования, он бы не ушел дальше его создателей, университетов и группы энтузиастов, что и произошло в реальности, это обусловлено не только проблемой обработки недетерминированных случаев, но и порогом вхождения, сложностью эффективной машинной реализации, эффективных программ. Даже более конкурентноспособный Лисп, который имеет аппаратно реализованные лисп-машины, не смог противостоять семейству императивных языков и их фреймворков. Так что более реалистичным является мир, в котором Лисп стал первым языком программирования и первым языком программировния, который стал бы использоваться во многих областях. 

## Список использованных источников:
1. https://en.wikipedia.org/wiki/Prolog
2. https://ru.wikipedia.org/wiki/%D0%98%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F_%D0%BF%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D1%85_%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BE%D0%B2
3. https://swi-prolog.org/features.html