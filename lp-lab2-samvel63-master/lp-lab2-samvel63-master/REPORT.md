#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Мхитарян С.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|   30.10.17   |      4        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Существуют различные подходы к решению логических задач:
* Метод рассуждений;
* Метод таблиц;
* Метод графов;
* Метод блок-схем;
* Метод бильярда;
* Метод кругов Эйлера.

Пожалуй, самым простым способом являет метод рассуждений. Его идея состоит в том, что мы проводим рассуждения, используя последовательно все условия задачи, и приходим к выводу, который и будет являться ответом задачи.

Prolog основан на языке предикатов математической логики дизъюнктов Хорна. Из этого следует, что на прологе легко реализовать метод рассуждений, проверяя все случаи на истинность. 

## Задание

Борисов, Кириллов, Данин и Савин инженеры. Один из них автомеханик, другой химик, третий строитель, четвертый радиотехник. Борисов, который обыгрывает в шахматы Данина, но проигрывает Савину, бегает на лыжах лучше того инженера, который моложе его, и ходит в театр чаще, чем тот инженер, который старше Кириллова. Химик, который посещает театр чаще, чем автомеханик, но реже, чем строитель, не является ни самым молодым, ни самым старшим из этой четверки. Строитель, который на лыжах бегает хуже, чем радиотехник, как правило, проигрывает в шахматных сражениях автомеханику. Самый пожилой из инженеров лучше всех играет в шахматы и чаще всех бывает в театре, а самый молодой лучше всех ходит на лыжах. Назовите профессии каждого из инженеров, если известно, что ни в спорте, ни в приверженности к театру среди нет двух одинаковых.

## Принцип решения

```prolog
memb(X,[X|_]). % проверка на принадлежность
memb(X,[_|Y]):-
memb(X,Y).

subl(Sub,List):- % проверка вхождения
    app(_,Y2,List), %списка в качестве подсписка
    app(Sub,_,Y2).

rem(X, [X|T], T). % удаление из списка
rem(X, [Y|T], [Y|T1]):-
    rem(X,T,T1).

perm([],[]):-!. % перестановка списка
perm(L,[X|T]):-
    rem(X,L,R),
    perm(R,T).

perm1([],[]):-!. % перестановка списка
perm1(L,[X|T]):-
    rem(X,L,R),
    perm1(R,T), !.

surname(borisov).
surname(kirillov).
surname(danin).
surname(savin).

prof(mechanic).
prof(chemist).
prof(builder).
prof(radioman).

last([_,_,_,D],D).
third([_,_,C,_],C).
second([_,B,_,_],B).
first([A,_,_,_],A).

xy(X,Y,[X|T]):-
    memb(Y,T).
xy(X,Y,[A|T]):-
    xy(X,Y,T).

result(Res):- %Борисов, Кириллов, Данин, Санин
    perm([borisov, kirillov, danin, savin], [X1,X2,X3,X4]),
    perm([mechanic, chemist, builder, radioman],[Y1,Y2,Y3,Y4]),

    Res = [p(X1,Y1),p(X2,Y2),p(X3,Y3),p(X4,Y4)],

    \+last(Res,p(borisov,_)),
    \+first(Res,p(borisov,_)),
    \+last(Res,p(kirillov,_)),

    \+first(Res,p(_,chemist)),
    \+last(Res,p(_,chemist)),

    perm(Res,Chess),
    last(Res,Oldest),
    last(Chess,Oldest),
    \+last(Chess,p(borisov,_)),
    \+first(Chess,p(borisov,_)),

    xy(p(borisov,_),p(savin,_),Chess),
    xy(p(danin,_),p(borisov,_),Chess),

    xy(p(_,builder),p(_,mechanic),Chess),

    perm(Res,Theater),
    last(Theater,Oldest),

    xy(p(_,mechanic),p(_,chemist),Theater),
    xy(p(_,chemist),p(_,builder),Theater),

    xy(p(kirillov,_),A,Res),
    xy(A,p(borisov,_),Theater),

    perm(Res,Ski),
    first(Res,Youngest),
    last(Ski,Youngest),
    \+first(Ski,p(borisov,_)),
    xy(p(_,builder),p(_,radioman),Ski). %окончание предиката?

    xy(M,p(borisov,_),Res),

    xy(M,p(borisov,_),Ski).
```

## Тест
```prolog
| ?- result(X).

X = [p(kirillov,mechanic),p(borisov,builder),p(danin,chemist),p(savin,radioman)] ? ;

X = [p(kirillov,mechanic),p(danin,chemist),p(borisov,builder),p(savin,radioman)] ? ;

no
```

## Выводы

При создании программы я старался сделать ее максимально эффективной, поэтому перед каждым следующим перебором вариантов я старался отсечь все лишние случаи. Менее эффективный вариант- сначала инициализировать все возможные варианты и затем отсекать не нужные.<br>
Программа не является противоречивой:<br>
Умение инженеров играть в шахматы (по возрастанию):<br>
Chess = [p(danin,chemist),p(borisov,builder),p(kirillov,mechanic),p(savin,radioman)]<br>
Частота посещения театра инженерами (по возрастанию):<br>
Theater = [p(kirillov,mechanic),p(danin,chemist),p(borisov,builder),p(savin,radioman)]<br>
Умение инженеров бегать на лыжах, 3 возможных варианта (по возрастанию):<br>
Ski = [p(danin,chemist),p(borisov,builder),p(savin,radioman),p(kirillov,mechanic)]<br>

Всё это не противоречит условиям:<br>
Борисов:

    выигрывает в шахматы у Данина
    проигрывает в шахматы Савину
    бегает на лыжах лучше того, кто моложе него
    ходит в театр чаще того, кто старше Кириллова

Химик:

    посещает театр чаще механика
    посещает театр реже строителя
    не является самым молодым
    не является самым старым

Строитель:

    бегает на лыжах хуже радиотехника
    проигрывает в шахматы автомеханику

Самый пожилой из всех:

    лучше всех играет в шахматы
    чаще всех бывает в театре

Самый молодой:

    лучше всех ходит на лыжах

Следовательно, программа составлена эффективно и непротиворечиво.
